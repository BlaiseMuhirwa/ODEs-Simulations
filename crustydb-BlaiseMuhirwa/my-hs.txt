
Author: Blaise Munyampirwa
CMSC 23500, Winter 2022


1. DATA STRUCTURES AND GENERAL DESIGN 

In this implementation, the following structures were added/modified.

a) The HeapFile structure 

    pub(crate) struct HeapFile {
        pub file: Arc<RwLock<File>>,
        // The following are for profiling/ correctness checks
        pub read_count: AtomicU16,
        pub write_count: AtomicU16,
    }

b) The HeapFileIterator structure 

    pub struct HeapFileIterator {
        heapfile: Arc<HeapFile>,
        pub tid: TransactionId,
        pub container_id: ContainerId,
        pub page_iter: PageIter
        pub index: u16,
    }

c) The StorageManager structure 

    #[derive(Serialize, Deserialize)]
    pub struct StorageManager {
        /// Path to database metadata files.
        pub storage_path: String,
        is_temp: bool,
        #[serde(skip)]
        container_files: Arc<RwLock<HashMap<ContainerId, HeapFile>>>,
    }


In the design of the heapfile, we maintain a file Arc<RwLock<File>> inside the HeapFile 
struct. Since the interface of the HeapFile does not allow passing mutable references, we  
use Arc<RwLoc<>> for the File corresponding to this structure in order to have internal
mutability (i.e., modify the state of the file via writes). In order to check which pages
are already in the heapfile upon reads, we maintain an invariant that the first 8 bytes
in the file indicate the number of pages stored. A consequence of this mini-design choice is
that whenever we want to read a particular page with a given page_id, it is sufficient to
check whether this page_id is less than the value of the first byte in the file in order
to determine if this is a valid access (Notice, however, that this works because we 
assume that page_ids are added in an increasing sequence).

One advantage of this design choice is simplicity since we need not store any other meta-
data to know the location of a certain page. For instance, if we have 3 pages in a heapfile,
and we want to read a page with page_id 2, its location will be at 8 + (2 * PAGE_SIZE).
This means that we have to skip the first 8 bytes, pages 0, and 1, and then find the location
of the desired page. 

For the storage manager (SM), the most notable design component consists of maintaining 
a mapping of container ids to respective heapfiles containing the pages for specific 
containers. Maintaining this hash table, controlled by the Reader-Writer lock, simplifies multiple 
parts of the implementation since it allows us to directly access the heapfile API. 
Upon shutdown, we serialize a hashtable of container id's to heapfile paths. This hashtable 
is written to a single JSON file in a prespecified directory. 

The last component in the overall desing is the HeapFileIterator. There was less design 
choices to make in this implementation since there are only a few a different ways the 
iterator can be implemented. We choose to simply iterate through pages one by one from 
smallest page_id (0) to the largest page_id stored in the heapfile. Then for each page,
we invoke the previously constructed page iterator. 


2. TIME SPENT & OTHER FEEDBACK

I roughly spent about 25 hours working on this assignment. In particular, what I liked 
most about this milestone is the amount of freedom we had with regards to different design
choices. I think this helped us to understand a bit more why and how different components
interact with each other. 









