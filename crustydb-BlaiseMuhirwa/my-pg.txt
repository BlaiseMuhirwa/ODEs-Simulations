
Author: Blaise Munyampirwa
CMSC 23500, Winter 2022


1. DATA STRUCTURES AND GENERAL DESIGN 

In this implementation, the following structures were added/modified.

a) The Header structure 

    pub(crate) struct Header {
        page_id: PageId,
        next_available_slot: SlotId,
        entries: HashMap<SlotId, Vec<SlotId>>,
    }

b) The Page structure 

    pub(crate) struct Page {
        header: Header,
        valid_slots: HashSet<SlotId>,
        data: [u8; PAGE_SIZE],
    }

To ensure that for each entry the header consumes at most 6 bytes per entry,
we utilize a HashMap (Header.entries), which uses 2 bytes for the key, and precisely
4 bytes for the value (first 2 bytes are offset of the offset in the page, and the 
last 2 bytes are the number of bytes for a particular record). In particular, notice
that Header.entries.get(key) is a vector of capacity 2 (always). Thus, this allows us
to use precisely 6 bytes for any incoming record. 

For additional metadata, we only use 4 bytes. The first 2 bytes correspond to page_id,
and the last 2 bytes keep track of the next insertion position in the table. The ability
to access this field speeds up our insertions since we do not have to iterate over the 
previous inserted entries. 

- Insertions: 
    New records are added at the start of the page. For instance, if records A,B, and C 
    were an incoming stream of bytes of size 20 bytes, 25 bytes, and 50 bytes respectively,
    the following will be state of page.data after performing these insertions. 

    page.data[0..20] = A 
    page.data[20..45] = B 
    page.data[45..95] = C 

    Although the page's metadata is subsequently changed upon insertions, the bytes for the 
    metadata are not copied to page.data until the page has to be serialized. In other words,
    if this page containing A,B,C has not been serialized yet, it will only contain the above
    bytes and nothing more. At this stage, the state of the metadata will be as follows (i.e.,
    page.header.entries):

    {
        slot_id 0: [0, 20],
        slot_id 1: [20, 25],
        slot_id 2: [45, 50]
    }
    As mentioned above, this HashMap maintains a correspondence of slots to a 2-sized vector whose
    entries are byte offset and byte size for each record in the table. 

- Deletions:
    When a new record is deleted, we update the state of the page by simply removing the 
    corresponding SlotId from the set of all valid slots. This set is maintained in Page.valid_slots.
    Crucially, this record is not deleted from Header.entries since new incoming records might use
    the SlotId of the previous record. 

    An advantage of this design is simplicity because we do not have to deal with reorganizing all 
    entries in the page upon deletions. Tracking valid slots and all entries that have been added 
    allows us to reduce the complexity of the implementation. One vulnerability of this design, however,
    is that it is harder to keep track of all internal fragmentations that can potentially be used to
    hold incoming records. The problem of adding a record that fits at the end of the table is easy.
    The more complicated part is adding a record where the largest contiguous block is smaller than
    this record's size, yet the table has enough space to hold this record. We address the latter 
    part by relying on the ability to identify previously deleted records so that we can re-use their
    space. 

- Serialization and Deserialization:
    when we want to serialize a new page into bytes, this is the time when the metadata's bytes are 
    copied over to Page.data. In particular, we maintain the invariant that Page metadata is added 
    at the end of the page while Page's records are added at the start of the page. 

    To be more precise, upon serialization, the last 2 bytes will hold page_id, the previous 2 bytes
    will hold the number of entries in the header's hashtable, and the previous 2 bytes will hold the 
    next_available_slot (field in Header struct). The remaining space at the end is filled with the 
    bytes of the key-value pairs in the header's hashtable. 
    Deserialization works precisely by assuming this invariant, and constructing a new page based on 
    the extracted bytes. 


2. TIME SPENT & OTHER FEEDBACK

I roughly spent about 20 hours working on this assignment. One thing I liked is the design component of 
the assignment. I felt like I had a chance to flex my design muscles by thinking at a low level about
what it is that I was trying to accomplish, and then leveraging my data structures knowledge to 
implement the project. 
I also noticed how powerful Rust is. I thought I knew, but I did not. This language truly makes sure 
developers can't write memory-buggy code. 





