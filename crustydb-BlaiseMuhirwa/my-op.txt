
Author: Blaise Munyampirwa
CMSC 23500, Winter 2022


1. DATA STRUCTURES AND GENERAL DESIGN 

In this implementation, the following structures were added/modified.

a) The Aggregator structure 

    struct Aggregator {
        agg_fields: Vec<AggregateField>,
        groupby_fields: Vec<usize>,
        schema: TableSchema,
        results: Vec<Tuple>,
        average_counts: HashMap<usize, Vec<u32>>,
    }

b) The Join structure (Nested-Loop Join)

    pub struct Join {
        predicate: JoinPredicate,
        left_child: Box<dyn OpIterator>,
        right_child: Box<dyn OpIterator>,
        schema: TableSchema,
        current_left_tuple: Option<Tuple>,
        open: bool,
    }

c) The Page structure 

    pub(crate) struct Page {
        header: Header,
        valid_slots: HashSet<SlotId>,
        data: [u8; PAGE_SIZE],
    }

d) The HashEqJoin structure 

    pub struct HashEqJoin {
        predicate: JoinPredicate,
        left_child: Box<dyn OpIterator>,
        right_child: Box<dyn OpIterator>,
        schema: TableSchema,
        hashed_buckets: HashMap<Field, Vec<Tuple>>,
        open: bool,
    }

- Aggregate Operations 
    To handle the state in the aggregation operations, I modified the Aggregator structure
    to maintain a vector of tuples(Aggregator.results) that have currently been appended to
    an aggregate at any point in time. Whenever a new tuple is to be added to the current 
    aggregate result (by calling merge_tuple_into_group), we check first to see if the 
    corresponding group already exists by iterating over all values in Aggregator.results.

    NOTE: The aggregation operation AggOp::Avg is handled differently from the rest of the 
    operations. Values are added to the current state of the aggregate, but the average is 
    not computed until the data has to be marshalled into an iterator. In other words, the 
    state of the aggregate is not entirely correct (when we have AggOp::Avg in the output
    schema) until the data is requested via the Aggregator::iterator(). To compute the average
    we maintain sums for each field that needs to be averaged, and the corresponding averages 
    are computed during the execution of Aggregator::iterator() function. 


- Join Operations
    The nested-loop join and hash equi-join are handled in a very similar fashion except for a few
    key differences. First, state in the nested-loop join is maintained by keeping track of the 
    current tuple in the left table in the Join structure. This allows subsequent calls to next() 
    in the iterator to determine precisely which left tuple is being matched with all tuples in the 
    right table that fulfill the join selection predicate. 

    State in the hash equi-join, on the other hand, is maintained by building a hashtable on the 
    left child (table). We maintain a hashable HashMap<Field, Vec<Tuple>> whose keys are correspond 
    to the left index for the join and values correspond to all possible tuples for the particular 
    key in the hash table. During join operations, for any tuple from the right child, it is sufficient
    to only consider left tuples in the corresponding bucket. Crucially, it is important to note that the 
    left child is chosen by default as the table on which to construct the hash table, and the right 
    child is used for probing. This design decision does not consider the table which is of smaller 
    length as that which ought to be used to construct the hash table. This minor optimization will be 
    implemented in Milestone 4. 


2. TIME SPENT & OTHER FEEDBACK

I roughly spent about 10-13 hours working on this assignment. Overall, I felt like this assignment was 
much more intuitive and easier to implement than the previous milestones. One reason could be that 
conceptually, it is easy to understand how to construct aggregates and implement nested-loop join/hash join.





